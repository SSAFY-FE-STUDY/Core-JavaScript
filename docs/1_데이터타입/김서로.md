# ① 변수와 식별자
> 변수와 식별자를 혼용하는 경우가 많지만 사실 둘은 다른 의미를 가지고 있다 ‼️
  
- 변수: 변할 수 있는 데이터
    - 이때, 데이터에는 숫자, 문자열, 객체, 배열이 포함된다.
- 식별자: 어떤 데이터를 식별하는 데 사용하는 이름
    - 변수명, 함수명, 클래스명 등을 말한다.
    - 모든 데이터는 메모리에 저장되어 있지만 메모리 주소로 데이터에 접근하는 것은 쉽지 않다.
    - @5001와 같은 메모리 주소로 접근하는 것은 비효율적이다.
    - 따라서, 메모리 주소에 식별자를 연결하고 이 식별자를 호출하여 데이터에 접근한다.

# ② 메모리 동작 방식
### ➊ 변수 선언과 할당 시
```
var a = 'abc';
```

예상되는 메모리 동작 방식은 다음과 같다.  

|주소|데이터|
|--|--|
|@1002|이름: a, 값: 'abc'|

하지만 실제로는 해당 위치에 문자열 'abc'를 직접 저장하지 않는다.  
메모리를 **변수 영역**과 **데이터 영역**으로 구분하여 데이터를 저장한다.  
실제 메모리 동작 방식은 다음과 같다.  
  
### 변수 영역
|주소|데이터|
|--|--|
|@1002|이름: a, 값: @5004|

### 데이터 영역
|주소|데이터|
|--|--|
|@5004|'abc'|

이처럼 변수 영역에 값을 직접 대입하는 게 아니라  
데이터 영역에 값을 저장한 후 이 메모리의 주소를 변수 영역에 저장한다.  
  
> 🤔 왜 변수 영역과 데이터 영역을 분리하는 것일까?  

ⓐ 데이터 변환을 자유롭게 하고 메모리를 더욱 효율적으로 관리하기 위해서  
ⓑ 중복된 데이터의 처리 효율을 높이기 위해서  
  
(ex)  
만약 a부터 z까지의 변수에 숫자 5를 저장한다고 생각해보자!  
변수 영역과 데이터 영역을 분리하지 않는다면,  
숫자 5를 알파벳 개수(26)만큼 저장해야 할 것이다.  
똑같은 데이터를 저장하는 데 26 * 8byte 만큼의 메모리를 사용한다면 매우 비효율적이다.  
따라서, 숫자 5는 데이터 영역에 한 번만 저장하고 이 메모리 주소를 a부터 z까지의 변수에 저장한다면 메모리를 더욱 효율적으로 사용할 수 있을 것이다.  
  
### ➋ 객체 선언과 할당 시
참조형 데이터(객체)를 저장할 때 메모리 동작 방식은 어떻게 될까?  

```
var obj = {
    a: 1,
    b: 'abc'
};
```
obj는 객체 안의 변수(프로퍼티)를 추가로 갖고 있다.  
따라서 이 **프로퍼티만을 위한 변수 영역이 별도로 존재**한다!  
🚨 but, 데이터 영역은 기존의 메모리 공간을 그대로 활용한다.  
  
### 변수 영역
|주소|데이터|
|--|--|
|@1002|이름: obj, 값: @5001|

### 데이터 영역
|주소|데이터|
|--|--|
|@5001|@7103 ~ @7104|
|@5003|1|
|@5004|'abc'|

### 객체 @5001의 변수 영역
|주소|데이터|
|--|--|
|@7103|이름: a, 값: @5003|
|@7104|이름: b, 값: @5004|

변수 영역이 또 하나 생긴다는 점은 독특하다.  
그러나 이러한 점 때문에 객체는 불변성을 보장받지 않는다.  
  
### ➌ 객체 복사 시
```
var obj1 = {
    a: 1,
    b: 'abc'
};

var obj2 = obj1;
obj2.a = 2; // obj2의 프로퍼티 변경

console.log(obj1.a); // 2 출력
console.log(obj2.a); // 2 출력
```

위의 예시에서 obj1을 obj2에 복사하였다.  
그리고 obj2의 프로퍼티(a)를 수정하였다.  
그러나 실제 출력 결과는 보면 obj1와 obj2 모두 수정된 것을 확인할 수 있다.  
왜 두 객체 모두 수정된 것일까?  
  
한 문장으로 설명하자면,  
obj1와 obj2 모두 같은 객체의 주소를 저장하고 있기 때문이다.  
  
obj1을 obj2에 복사할 때 객체를 새로 생성하여 대입하는 것이 아니라  
이미 존재하는 객체의 주소만 복제하였다.  
  
> 🤔 객체를 복사할 때 실제 메모리에서는 어떻게 동작할까?  
  
`var obj2 = obj1;`  
먼저 obj2에 obj1을 할당(복사)하면 메모리 구조는 아래처럼 바뀐다.  
변수 영역에서 obj1가 가지고 있는 값인 **@5001을 그대로 복사**하였다.  

### 변수 영역
|주소|데이터|
|--|--|
|@1002|이름: obj1, 값: @5001|
|@1003|이름: obj2, 값: @5001|

### 데이터 영역
|주소|데이터|
|--|--|
|@5001|@7103 ~ @7104|
|@5003|1|
|@5004|'abc'|

### 객체 @5001의 변수 영역
|주소|데이터|
|--|--|
|@7103|이름: a, 값: @5003|
|@7104|이름: b, 값: @5004|

`obj2.a = 2;`  
이제 obj2의 프로퍼티 a를 2로 변경하면 메모리 구조는 다음과 같이 바뀐다.  
**객체 @5001의 변수 영역**에서 a가 @5005 주소를 참조하도록 변경되었다!  

### 변수 영역
|주소|데이터|
|--|--|
|@1002|이름: obj1, 값: @5001|
|@1003|이름: obj2, 값: @5001|

### 데이터 영역
|주소|데이터|
|--|--|
|@5001|@7103 ~ @7104|
|@5003|1|
|@5004|'abc'|
|@5005|2|

### 객체 @5001의 변수 영역
|주소|데이터|
|--|--|
|@7103|이름: a, 값: @5005|
|@7104|이름: b, 값: @5004|

문제는 여기서부터다.  
@7103 메모리에 위치하는 a는 @5003 → @5005 으로 변경되었지만,  
obj1와 obj2는 여전히 같은 메모리 주소인 @5001을 공유하고 있다.  
  
그렇기 때문에 obj2의 프로퍼티를 변경하면 obj1에도 반영되는 것이다!  
(애초에 같은 객체를 참조하고 있기 때문에)  
  
원본 객체를 손실하지 않으면서 사본 객체를 생성하려면  
**깊은 복사**를 해야 한다.  

# ③ 깊은 복사
깊은 복사를 하면 중첩 객체까지 모두 복사되며  
중첩된 객체에서 프로퍼티를 변경하여도 원복 객체가 손실되지 않는다.  
  
깊은 복사를 하는 코드는 다음과 같다.  

```
var copyObjectDeep = function(target) {
    var result = {};
    if (typeof target === 'object' && target !== null) {
        for (var prop in target) {
            result[prop] = copyObjectDeep(target[prop]);
        }
    } else {
        result = target;
    }
    return result;
};
```

`copyObjectDeep` 함수는 내부 프로퍼티를 순회하며 자기 자신을 재귀적으로 호출한다.  
이 함수를 사용하면 원본과 사본이 서로 완전히 다른 객체를 참조하게 된다.  

# ④ undefined vs null

### ➊ undefined
```
var result;
```
_var_ 키워드로 변수를 선언하면 자바스크립트 엔진은 값을 저장하기 위한 준비를 한다.  
  
변수 선언문이 실행되면 아래의 두 단계를 거친다.  
  
① 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.  
② 확보된 메모리에 _undefined_ 를 할당한다.  
  
> 왜 _undefined_ 를 할당할까 ❓
  
만약 _undefined_ 를 할당하지 않고 ①번 과정만 수행한다고 가정해보자.  
확보된 메모리 공간에는 이전에 할당되었던 쓰레기 값이 존재할 것이다.  
  
> 왜 쓰레기 값이 존재할까 ❓

```
var result = 100;
result = 200;
```
왜 쓰레기 값이 존재하는지 설명하기 위해 예시를 들어보겠다.  
위의 코드에서 _result_ 변수에 처음 100을 할당하고  
그 다음에 200을 재할당한다.  
  
이때 이전 값 100이 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 200을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 200을 저장한다.  
따라서 _result_ 식별자는 200이 저장된 메모리 공간과 연결되며
이전에 100이 저장되어 있던 메모리 공간은 어떤 식별자와도 연결되어 있지 않다.  

![](https://velog.velcdn.com/images/okxooxoo/post/8b4496bd-d167-46b3-b7d8-2277fe171435/image.jpeg)


이처럼 메모리 상에는 더이상 사용하지 않아 어떤 식별자와도 연결되어 있지 않은 값들이 많다.  
이러한 불필요한 값들을 **쓰레기 값**이라고 한다 ❗️  
  
자바스크립트는 개발자가 변수를 초기화하지 않고 선언만 했을 때 실수로 쓰레기 값을 사용하지 않도록 _undefined_ 라는 데이터 타입으로 초기화한다.  
  
### ➋ null
_null_ 은 변수에 값이 없다는 것을 개발자가 **의도적**으로 명시할 때 사용한다.  
```
var result = 100;
result = null;
```
변수에 _null_ 을 할당하는 것은 변수가 이전에 참조하던 값인 100을 더 이상 참조하지 않겠다는 의미다.  
따라서 기존의 식별자와 연결 고리를 끊어버리는 것이다.  

### ➌ 그렇다면 null과 undefined의 차이는 무엇일까 ❓

_null_ 은 변수에 값이 없다는 것을 드러내기 위해 개발자가 **의도적**으로 할당하는 값이다.  
그러나 _undefined_ 는 선언이 되고 초기화되지 않았기 때문에 자바스크립트 엔진이 할당하는 값이다.  
따라서 변수에 _undefined_ 가 할당되어 있으면 **초기화되지 않은 변수**라는 의미가 더 강하다.  

> **앞으로 사용할 것이지만 초기화되지 않은 변수**와
**의도적으로 값을 비워둔 변수**에는 큰 차이가 있다 ❗️

_null_ 과 _undefined_ 의 차이는 바로 이런 것이다.  