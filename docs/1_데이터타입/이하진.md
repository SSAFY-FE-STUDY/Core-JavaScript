# 01. 데이터 타입

## 01. 데이터 타입의 종류

**Data Type**

- Primitive type
    - Number / String / Boolean / null / undefined / Symbol
- Reference type
    - Object
        - Array / Function / Date / RegExp / Map, WeakMap / Set, WeakSet

⇒ 기본형(Primitive type)은 값이 담긴 주솟값을 바로 복제

⇒ 참조형(Reference type)은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제

<br />

## 02. 데이터 타입에 관한 배경지식

### 1-2-1 메모리와 데이터

- 비트는 고유한 식별자를 지니고 있음 (바이트는 시작하는 비트의 식별자로 위치를 파악)

⇒ 모든 데이터는 바이트 단위의 식별자, 메모리 주솟값을 통해 서로 구분하고 연결

### 1-2-2 식별자와 변수

- 변수: 변할 수 있는 무언가(데이터)
- 식별자(=변수명): 데이터를 식별하는 데 사용하는 이름

<br />

## 03. 변수 선언과 데이터 할당

### 1-3-1 변수 선언

```jsx
var a;
```

| 주소 | … | 1002 | 1003 | 1003 | … |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  |  | 이름: a
값: |  |  |

### 1-3-2 데이터 할당

```jsx
var a;
a = 'abc';

// 변수와 할당을 한 번에
var a = 'abc';
```

| 주소 | … | 1002 | 1003 | 1003 | … |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  |  | 이름: a
값: @5004 |  |  |

| 주소 | … | 5002 | 5003 | 5004 | … |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  |  |  | ‘abc’ |  |

1) 변수 영역에 빈 공간(@1003)을 확보한다.

2) 확보한 공간의 식별자를 a로 지정한다.

3) 데이터 영역의 빈 공간(@5004)에 문자열 ‘abc’를 저장한다.

4) 변수 영역에서 a라는 식별자를 검색한다.

5) 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

⇒ 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐

<br />

## 04. 기본형 데이터와 참조형 데이터

### 1-4-1 불변값

- 변수와 상수를 구분하는 성질은 ‘변경 가능성’
- 변경 가능성의 대상은 **변수 영역 메모리**

(*불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역의 메모리**)

### 1-4-3 가변값

- 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재
- 데이터 영역에 저장된 값은 모두 불변값

### 1-4-3 변수 복사 비교

```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

| 주소 | 1001 | 1002 | 1003 | 1004 | 1005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값: @5001 | 이름: b
값: @5004 | 이름: obj1
값: @5002 | 이름: obj2
값: @5002 |  |
| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
| 데이터 | 10 | @7103 ~ ? | ‘ddd’ | 15 | 20 |

| 주소 | 7103 | 7104 |
| --- | --- | --- |
| 데이터 | 이름: c
값: @5005 | 이름: d
값: @5003 |

```jsx
a !== b
obj1 === obj2
```
<br />

## 05. 불변객체

### 1-5-1 불변 객체를 만드는 간단한 방법

```jsx
var copyObject = function (target) {
	var result = {};
	for (var prop in targer) {
		result[prop] = target[prop];
	}
	return result;
}
```

### 1-5-2 얕은 복사와 깊은 복사

- 얕은 복사: 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사: 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법

```jsx
// 깊은 복사
var copyObjectViaJSON = function (target) {
	return JSON.parse(JSON.stringify(target));
}

var obj = {
	a: 1,
	b: {
		c: null,
		d: [1,2],
		func1: function () { console.log(3); }
	},
	func2: function () { console.log(4); } 
}

var obj2 = copyObjectViaJSON(obj);

obj2.a = 3;
obj2.b.c = 4;
obj.b.d[1] = 3;

console.log(obj);   // { a: 1, b: { c: null, d: [1, 3], func1: f() }, func2: f() }
console.log(obj2);  // { a: 3, b: { c: 4, d: [1, 2] }}
```

<br />

## 06. undefined와 null

- 자바스크립트 엔진이 `undefined`를 반환하는 경우
    
    1️⃣ 값을 대입하지 않은 변수, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
    
    2️⃣ 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
    
    3️⃣ return문이 없거나 호출되지 않는 함수의 실행 결과
    

⇒ 값으로써 어딘가에 할당된 `undefined`는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 `undefined`는 문자 그대로 값이 없음을 나타냄
